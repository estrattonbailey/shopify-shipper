(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
// Best place to find information on XHR features is:
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

var reqfields = [
  'responseType', 'withCredentials', 'timeout', 'onprogress'
]

// Simple and small ajax function
// Takes a parameters object and a callback function
// Parameters:
//  - url: string, required
//  - headers: object of `{header_name: header_value, ...}`
//  - body:
//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)
//      + FormData (doesn't set content type so that browser will set as appropriate)
//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body
//  - cors: If your using cross-origin, you will need this true for IE8-9
//
// The following parameters are passed onto the xhr object.
// IMPORTANT NOTE: The caller is responsible for compatibility checking.
//  - responseType: string, various compatability, see xhr docs for enum options
//  - withCredentials: boolean, IE10+, CORS only
//  - timeout: long, ms timeout, IE8+
//  - onprogress: callback, IE10+
//
// Callback function prototype:
//  - statusCode from request
//  - response
//    + if responseType set and supported by browser, this is an object of some type (see docs)
//    + otherwise if request completed, this is the string text of the response
//    + if request is aborted, this is "Abort"
//    + if request times out, this is "Timeout"
//    + if request errors before completing (probably a CORS issue), this is "Error"
//  - request object
//
// Returns the request object. So you can call .abort() or other methods
//
// DEPRECATIONS:
//  - Passing a string instead of the params object has been removed!
//
exports.ajax = function (params, callback) {
  // Any variable used more than once is var'd here because
  // minification will munge the variables whereas it can't munge
  // the object access.
  var headers = params.headers || {}
    , body = params.body
    , method = params.method || (body ? 'POST' : 'GET')
    , called = false

  var req = getRequest(params.cors)

  function cb(statusCode, responseText) {
    return function () {
      if (!called) {
        callback(req.status === undefined ? statusCode : req.status,
                 req.status === 0 ? "Error" : (req.response || req.responseText || responseText),
                 req)
        called = true
      }
    }
  }

  req.open(method, params.url, true)

  var success = req.onload = cb(200)
  req.onreadystatechange = function () {
    if (req.readyState === 4) success()
  }
  req.onerror = cb(null, 'Error')
  req.ontimeout = cb(null, 'Timeout')
  req.onabort = cb(null, 'Abort')

  if (body) {
    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')

    if (!global.FormData || !(body instanceof global.FormData)) {
      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')
    }
  }

  for (var i = 0, len = reqfields.length, field; i < len; i++) {
    field = reqfields[i]
    if (params[field] !== undefined)
      req[field] = params[field]
  }

  for (var field in headers)
    req.setRequestHeader(field, headers[field])

  req.send(body)

  return req
}

function getRequest(cors) {
  // XDomainRequest is only way to do CORS in IE 8 and 9
  // But XDomainRequest isn't standards-compatible
  // Notably, it doesn't allow cookies to be sent or set by servers
  // IE 10+ is standards-compatible in its XMLHttpRequest
  // but IE 10 can still have an XDomainRequest object, so we don't want to use it
  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))
    return new XDomainRequest
  if (global.XMLHttpRequest)
    return new XMLHttpRequest
}

function setDefault(obj, key, value) {
  obj[key] = obj[key] || value
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _utils = require('./../lib/utils.js');

exports.default = function () {

	return {
		make: function make(name) {
			var existing = (0, _utils.selectNodes)('[name="' + name + '"]', this._context);
			if (existing) return existing;
			var select = (0, _utils.createNode)('select', { name: name });
			this._context.appendChild(select);
			return select;
		},
		context: function context(el) {
			this._context = el;
			return this;
		},
		update: function update(el) {
			var options = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

			var values = void 0,
			    option = void 0;

			if (typeof options != 'string') {
				values = Object.keys(options);
			} else {
				values = Countries[options].provinces || false;
			}

			el.innerHTML = '';
			el.value = '';

			if (values) {
				el.style.visibility = 'visible';
			} else {
				el.style.visibility = 'hidden';
				return;
			}
			for (var i = 0; i < values.length; i++) {
				var value = values[i];
				option = (0, _utils.createNode)('option', { value: value });
				option.innerHTML = value;
				el.add(option);
			}
		}
	};
};

},{"./../lib/utils.js":8}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _mock = require('./mock');

var _mock2 = _interopRequireDefault(_mock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nanoajax = require('nanoajax');

var data = void 0;
var endCb = void 0;

function toQueryString(obj) {
	var str = '';
	for (var key in obj) {
		str += key + '=' + obj[key] + '&';
	}
	return str.slice(0, -1);
}

function prepare() {
	nanoajax.ajax({ url: _mock2.default.prepare, body: toQueryString(data), method: "post" }, get);
}

function get() {
	nanoajax.ajax({ url: _mock2.default.get }, endCb);
}

exports.default = function (inputs, cb) {
	data = inputs;
	endCb = cb;
	prepare();
};

},{"./mock":5,"nanoajax":1}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {

	return {
		isLocked: false,
		register: function register() {
			for (var _len = arguments.length, els = Array(_len), _key = 0; _key < _len; _key++) {
				els[_key] = arguments[_key];
			}

			this.els = els;
		},
		lock: function lock() {
			for (var i = 0; i < this.els.length; i++) {
				this.els[i].disabled = true;
			}
			this.isLocked = true;
		},
		unLock: function unLock() {
			for (var i = 0; i < this.els.length; i++) {
				this.els[i].disabled = false;
			}
			this.isLocked = false;
		}
	};
};

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  prepare: 'http://demo7063601.mockable.io/prepare',
  get: 'http://demo7063601.mockable.io/get-shipping-rates'
};

},{}],6:[function(require,module,exports){
'use strict';

/**
 * Object.assign fallback
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
if ('function' != typeof Object.assign) {
  Object.assign = function (target) {
    'use strict';

    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    target = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];
      if (source != null) {
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }

    return target;
  };
}

},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (data, modelData) {
	var el = (0, _utils.selectNodes)('[data-type="result"]', this);
	data = JSON.parse(data);

	if (!data['shipping_rates']) return;
	var rates = data['shipping_rates'];
	var string = '';

	for (var i = 0; i < rates.length; i++) {
		string += rates[i].name + ": " + rates[i].price + "\r\n";
	}

	el.innerHTML = string;
};

var _utils = require('./utils');

},{"./utils":8}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.selectNodes = selectNodes;
exports.createNode = createNode;
exports.addProps = addProps;
exports.addEvent = addEvent;
function nodeArray(nodeList) {
	return [].slice.call(nodeList);
}

function selectNodes(string) {
	var el = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	var nodes = (el || document).querySelectorAll(string);
	if (!nodes.length) return false;
	var nodesArray = nodeArray(nodes);
	if (nodesArray.length == 1) return nodesArray[0];
	return nodesArray;
}

function createNode(name, attrs) {
	var el = document.createElement(name.toString());

	!!attrs && Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});

	return el;
}

function addProps() {
	var isNode = prop.nodeType ? true : false;
	var isNumber = 'number' === typeof prop ? true : false;

	var key = isNumber || isNode ? 'range' : 'options';

	if (isNode || isNumber) {
		Object.defineProperty(target, key, {
			value: prop,
			writable: true
		});
	} else if (!isNode) {
		_extends(target.options, prop);
	}
}

function addEvent(obj, type, fn) {
	if (obj.attachEvent) {
		obj['e' + type + fn] = fn;
		obj[type + fn] = function () {
			obj['e' + type + fn](window.event);
		};
		obj.attachEvent('on' + type, obj[type + fn]);
	} else obj.addEventListener(type, fn, false);
}

},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

require('./lib/polyfills');

var _utils = require('./lib/utils');

var _ajax = require('./lib/ajax');

var _ajax2 = _interopRequireDefault(_ajax);

var _response = require('./lib/response');

var _response2 = _interopRequireDefault(_response);

var _lock = require('./lib/lock');

var _lock2 = _interopRequireDefault(_lock);

var _Select = require('./lib/Select');

var _Select2 = _interopRequireDefault(_Select);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (el) {
	var args = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	var instance = void 0;

	var settings = {
		endpoints: ['/cart/prepare_shipping_rates', '/cart/async_shipping_rates'],
		selectContainer: '[data-type="select-container"]',
		responseCb: _response2.default,
		defaultCountry: "United States"
	};
	_extends(settings, args);

	var selectWrap = (0, _utils.selectNodes)(settings.selectContainer, el);

	var select = (0, _Select2.default)().context(selectWrap);
	var country = select.make('country');
	var province = select.make('province');
	var model = {
		isLocked: false,
		data: {}
	};

	(0, _utils.addEvent)(country, 'change', function (e) {
		model.country = e.target.value;
	});

	(0, _utils.addEvent)(province, 'change', function (e) {
		model.province = e.target.value;
	});

	select.update(country, Countries);

	function makeDescriptor(prop) {
		return {
			get: function get() {
				return this.data[prop];
			},
			set: function set(val) {
				this.data[prop] = val;
			}
		};
	}

	Object.defineProperty(model, 'country', {
		get: function get() {
			return this.data.country;
		},
		set: function set(val) {
			this.data.country = val;
			country.value = val;
			select.update(province, val);
			this.province = province.value;
		}
	});

	Object.defineProperty(model, 'province', makeDescriptor('province'));
	Object.defineProperty(model, 'zip', makeDescriptor('zip'));

	var zip = (0, _utils.selectNodes)('[name="zip"]', el);

	(0, _utils.addEvent)(zip, 'blur', function (e) {
		model.zip = zip.value;
	});

	var lock = (0, _lock2.default)();
	lock.register(country, province, zip);

	//Handle the submission of the form
	(0, _utils.addEvent)(el, 'submit', function (e) {
		e.preventDefault();

		if (lock.isLocked) return false;
		lock.lock();

		(0, _ajax2.default)(model.data, function (code, data) {
			lock.unLock();
			settings.responseCb.call(el, data, model.data);
		});
	});

	model.country = settings.defaultCountry;

	return instance;
};

},{"./lib/Select":2,"./lib/ajax":3,"./lib/lock":4,"./lib/polyfills":6,"./lib/response":7,"./lib/utils":8}],10:[function(require,module,exports){
"use strict";

var _utils = require("./../src/lib/utils");

var _main = require("./../src/main");

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

document.addEventListener("DOMContentLoaded", function () {
	var els = (0, _utils.selectNodes)('[data-init="shipping-calculator"]');
	for (var i = 0; i < els.length; i++) {
		(0, _main2.default)(els[i], {
			endpoints: ['http://demo7063601.mockable.io/prepare', 'http://demo7063601.mockable.io/get-shipping-rates'],
			defaultCountry: "Canada"
		});
	}
});

},{"./../src/lib/utils":8,"./../src/main":9}]},{},[10])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbmFub2FqYXgvaW5kZXguanMiLCJzcmMvbGliL1NlbGVjdC5qcyIsInNyYy9saWIvYWpheC5qcyIsInNyYy9saWIvbG9jay5qcyIsInNyYy9saWIvbW9jay5qcyIsInNyYy9saWIvcG9seWZpbGxzLmpzIiwic3JjL2xpYi9yZXNwb25zZS5qcyIsInNyYy9saWIvdXRpbHMuanMiLCJzcmMvbWFpbi5qcyIsInRlc3QvZGV2LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM3R0E7O2tCQUVlLFlBQU07O0FBRXBC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QUExQixFQUE4QyxZQUFVO0FBQ3ZELEtBQUksTUFBTSx3QkFBWSxtQ0FBWixDQUFWO0FBQ0EsTUFBSyxJQUFJLElBQUUsQ0FBWCxFQUFhLElBQUUsSUFBSSxNQUFuQixFQUEwQixHQUExQixFQUE4QjtBQUM3QixzQkFBVSxJQUFJLENBQUosQ0FBVixFQUFrQjtBQUNqQixjQUFVLENBQ1Qsd0NBRFMsRUFFVCxtREFGUyxDQURPO0FBS2pCLG1CQUFlO0FBTEUsR0FBbEI7QUFPQTtBQUNELENBWEQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gQmVzdCBwbGFjZSB0byBmaW5kIGluZm9ybWF0aW9uIG9uIFhIUiBmZWF0dXJlcyBpczpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdFxuXG52YXIgcmVxZmllbGRzID0gW1xuICAncmVzcG9uc2VUeXBlJywgJ3dpdGhDcmVkZW50aWFscycsICd0aW1lb3V0JywgJ29ucHJvZ3Jlc3MnXG5dXG5cbi8vIFNpbXBsZSBhbmQgc21hbGwgYWpheCBmdW5jdGlvblxuLy8gVGFrZXMgYSBwYXJhbWV0ZXJzIG9iamVjdCBhbmQgYSBjYWxsYmFjayBmdW5jdGlvblxuLy8gUGFyYW1ldGVyczpcbi8vICAtIHVybDogc3RyaW5nLCByZXF1aXJlZFxuLy8gIC0gaGVhZGVyczogb2JqZWN0IG9mIGB7aGVhZGVyX25hbWU6IGhlYWRlcl92YWx1ZSwgLi4ufWBcbi8vICAtIGJvZHk6XG4vLyAgICAgICsgc3RyaW5nIChzZXRzIGNvbnRlbnQgdHlwZSB0byAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyBpZiBub3Qgc2V0IGluIGhlYWRlcnMpXG4vLyAgICAgICsgRm9ybURhdGEgKGRvZXNuJ3Qgc2V0IGNvbnRlbnQgdHlwZSBzbyB0aGF0IGJyb3dzZXIgd2lsbCBzZXQgYXMgYXBwcm9wcmlhdGUpXG4vLyAgLSBtZXRob2Q6ICdHRVQnLCAnUE9TVCcsIGV0Yy4gRGVmYXVsdHMgdG8gJ0dFVCcgb3IgJ1BPU1QnIGJhc2VkIG9uIGJvZHlcbi8vICAtIGNvcnM6IElmIHlvdXIgdXNpbmcgY3Jvc3Mtb3JpZ2luLCB5b3Ugd2lsbCBuZWVkIHRoaXMgdHJ1ZSBmb3IgSUU4LTlcbi8vXG4vLyBUaGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgYXJlIHBhc3NlZCBvbnRvIHRoZSB4aHIgb2JqZWN0LlxuLy8gSU1QT1JUQU5UIE5PVEU6IFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNvbXBhdGliaWxpdHkgY2hlY2tpbmcuXG4vLyAgLSByZXNwb25zZVR5cGU6IHN0cmluZywgdmFyaW91cyBjb21wYXRhYmlsaXR5LCBzZWUgeGhyIGRvY3MgZm9yIGVudW0gb3B0aW9uc1xuLy8gIC0gd2l0aENyZWRlbnRpYWxzOiBib29sZWFuLCBJRTEwKywgQ09SUyBvbmx5XG4vLyAgLSB0aW1lb3V0OiBsb25nLCBtcyB0aW1lb3V0LCBJRTgrXG4vLyAgLSBvbnByb2dyZXNzOiBjYWxsYmFjaywgSUUxMCtcbi8vXG4vLyBDYWxsYmFjayBmdW5jdGlvbiBwcm90b3R5cGU6XG4vLyAgLSBzdGF0dXNDb2RlIGZyb20gcmVxdWVzdFxuLy8gIC0gcmVzcG9uc2Vcbi8vICAgICsgaWYgcmVzcG9uc2VUeXBlIHNldCBhbmQgc3VwcG9ydGVkIGJ5IGJyb3dzZXIsIHRoaXMgaXMgYW4gb2JqZWN0IG9mIHNvbWUgdHlwZSAoc2VlIGRvY3MpXG4vLyAgICArIG90aGVyd2lzZSBpZiByZXF1ZXN0IGNvbXBsZXRlZCwgdGhpcyBpcyB0aGUgc3RyaW5nIHRleHQgb2YgdGhlIHJlc3BvbnNlXG4vLyAgICArIGlmIHJlcXVlc3QgaXMgYWJvcnRlZCwgdGhpcyBpcyBcIkFib3J0XCJcbi8vICAgICsgaWYgcmVxdWVzdCB0aW1lcyBvdXQsIHRoaXMgaXMgXCJUaW1lb3V0XCJcbi8vICAgICsgaWYgcmVxdWVzdCBlcnJvcnMgYmVmb3JlIGNvbXBsZXRpbmcgKHByb2JhYmx5IGEgQ09SUyBpc3N1ZSksIHRoaXMgaXMgXCJFcnJvclwiXG4vLyAgLSByZXF1ZXN0IG9iamVjdFxuLy9cbi8vIFJldHVybnMgdGhlIHJlcXVlc3Qgb2JqZWN0LiBTbyB5b3UgY2FuIGNhbGwgLmFib3J0KCkgb3Igb3RoZXIgbWV0aG9kc1xuLy9cbi8vIERFUFJFQ0FUSU9OUzpcbi8vICAtIFBhc3NpbmcgYSBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgcGFyYW1zIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkIVxuLy9cbmV4cG9ydHMuYWpheCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIC8vIEFueSB2YXJpYWJsZSB1c2VkIG1vcmUgdGhhbiBvbmNlIGlzIHZhcidkIGhlcmUgYmVjYXVzZVxuICAvLyBtaW5pZmljYXRpb24gd2lsbCBtdW5nZSB0aGUgdmFyaWFibGVzIHdoZXJlYXMgaXQgY2FuJ3QgbXVuZ2VcbiAgLy8gdGhlIG9iamVjdCBhY2Nlc3MuXG4gIHZhciBoZWFkZXJzID0gcGFyYW1zLmhlYWRlcnMgfHwge31cbiAgICAsIGJvZHkgPSBwYXJhbXMuYm9keVxuICAgICwgbWV0aG9kID0gcGFyYW1zLm1ldGhvZCB8fCAoYm9keSA/ICdQT1NUJyA6ICdHRVQnKVxuICAgICwgY2FsbGVkID0gZmFsc2VcblxuICB2YXIgcmVxID0gZ2V0UmVxdWVzdChwYXJhbXMuY29ycylcblxuICBmdW5jdGlvbiBjYihzdGF0dXNDb2RlLCByZXNwb25zZVRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGJhY2socmVxLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gc3RhdHVzQ29kZSA6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgIHJlcS5zdGF0dXMgPT09IDAgPyBcIkVycm9yXCIgOiAocmVxLnJlc3BvbnNlIHx8IHJlcS5yZXNwb25zZVRleHQgfHwgcmVzcG9uc2VUZXh0KSxcbiAgICAgICAgICAgICAgICAgcmVxKVxuICAgICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxLm9wZW4obWV0aG9kLCBwYXJhbXMudXJsLCB0cnVlKVxuXG4gIHZhciBzdWNjZXNzID0gcmVxLm9ubG9hZCA9IGNiKDIwMClcbiAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHN1Y2Nlc3MoKVxuICB9XG4gIHJlcS5vbmVycm9yID0gY2IobnVsbCwgJ0Vycm9yJylcbiAgcmVxLm9udGltZW91dCA9IGNiKG51bGwsICdUaW1lb3V0JylcbiAgcmVxLm9uYWJvcnQgPSBjYihudWxsLCAnQWJvcnQnKVxuXG4gIGlmIChib2R5KSB7XG4gICAgc2V0RGVmYXVsdChoZWFkZXJzLCAnWC1SZXF1ZXN0ZWQtV2l0aCcsICdYTUxIdHRwUmVxdWVzdCcpXG5cbiAgICBpZiAoIWdsb2JhbC5Gb3JtRGF0YSB8fCAhKGJvZHkgaW5zdGFuY2VvZiBnbG9iYWwuRm9ybURhdGEpKSB7XG4gICAgICBzZXREZWZhdWx0KGhlYWRlcnMsICdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVxZmllbGRzLmxlbmd0aCwgZmllbGQ7IGkgPCBsZW47IGkrKykge1xuICAgIGZpZWxkID0gcmVxZmllbGRzW2ldXG4gICAgaWYgKHBhcmFtc1tmaWVsZF0gIT09IHVuZGVmaW5lZClcbiAgICAgIHJlcVtmaWVsZF0gPSBwYXJhbXNbZmllbGRdXG4gIH1cblxuICBmb3IgKHZhciBmaWVsZCBpbiBoZWFkZXJzKVxuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCBoZWFkZXJzW2ZpZWxkXSlcblxuICByZXEuc2VuZChib2R5KVxuXG4gIHJldHVybiByZXFcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdChjb3JzKSB7XG4gIC8vIFhEb21haW5SZXF1ZXN0IGlzIG9ubHkgd2F5IHRvIGRvIENPUlMgaW4gSUUgOCBhbmQgOVxuICAvLyBCdXQgWERvbWFpblJlcXVlc3QgaXNuJ3Qgc3RhbmRhcmRzLWNvbXBhdGlibGVcbiAgLy8gTm90YWJseSwgaXQgZG9lc24ndCBhbGxvdyBjb29raWVzIHRvIGJlIHNlbnQgb3Igc2V0IGJ5IHNlcnZlcnNcbiAgLy8gSUUgMTArIGlzIHN0YW5kYXJkcy1jb21wYXRpYmxlIGluIGl0cyBYTUxIdHRwUmVxdWVzdFxuICAvLyBidXQgSUUgMTAgY2FuIHN0aWxsIGhhdmUgYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0LCBzbyB3ZSBkb24ndCB3YW50IHRvIHVzZSBpdFxuICBpZiAoY29ycyAmJiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIS9NU0lFIDEvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdFxuICBpZiAoZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KVxuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Rcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdChvYmosIGtleSwgdmFsdWUpIHtcbiAgb2JqW2tleV0gPSBvYmpba2V5XSB8fCB2YWx1ZVxufVxuIiwiaW1wb3J0IHtjcmVhdGVOb2RlLCBhZGRFdmVudCwgc2VsZWN0Tm9kZXN9IGZyb20gJy4vLi4vbGliL3V0aWxzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG5cblx0cmV0dXJuIHtcblx0XHRtYWtlOiBmdW5jdGlvbihuYW1lKXtcblx0XHRcdGxldCBleGlzdGluZyA9IHNlbGVjdE5vZGVzKCdbbmFtZT1cIicrbmFtZSsnXCJdJywgdGhpcy5fY29udGV4dCk7XG5cdFx0XHRpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZ1xuXHRcdFx0bGV0IHNlbGVjdCA9IGNyZWF0ZU5vZGUoJ3NlbGVjdCcse25hbWU6bmFtZX0pXG5cdFx0XHR0aGlzLl9jb250ZXh0LmFwcGVuZENoaWxkKHNlbGVjdClcblx0XHRcdHJldHVybiBzZWxlY3Rcblx0XHR9LFxuXHRcdGNvbnRleHQ6IGZ1bmN0aW9uKGVsKXtcblx0XHRcdHRoaXMuX2NvbnRleHQgPSBlbFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9LFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnM9ZmFsc2Upe1xuXHRcdFx0bGV0IHZhbHVlcywgb3B0aW9uXG5cblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucyAhPSAnc3RyaW5nJyl7XG5cdFx0XHRcdHZhbHVlcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZXMgPSBDb3VudHJpZXNbb3B0aW9uc10ucHJvdmluY2VzIHx8IGZhbHNlXG5cdFx0XHR9XG5cblx0XHRcdGVsLmlubmVySFRNTCA9ICcnXG5cdFx0XHRlbC52YWx1ZSA9ICcnXG5cblx0XHRcdGlmICh2YWx1ZXMpe1xuXHRcdFx0XHRlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpPTA7aSA8IHZhbHVlcy5sZW5ndGg7aSsrKXtcblx0XHRcdFx0bGV0IHZhbHVlID0gdmFsdWVzW2ldXG5cdFx0XHRcdG9wdGlvbiA9IGNyZWF0ZU5vZGUoJ29wdGlvbicse3ZhbHVlOnZhbHVlfSlcblx0XHRcdFx0b3B0aW9uLmlubmVySFRNTCA9IHZhbHVlXG5cdFx0XHRcdGVsLmFkZChvcHRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn1cbiIsImltcG9ydCBlbmRwb2ludHMgZnJvbSAnLi9tb2NrJ1xuXG5sZXQgbmFub2FqYXggPSByZXF1aXJlKCduYW5vYWpheCcpXG5cbmxldCBkYXRhXG5sZXQgZW5kQ2JcblxuZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhvYmope1xuXHRsZXQgc3RyID0gJydcblx0Zm9yIChsZXQga2V5IGluIG9iail7XG5cdFx0c3RyICs9IGtleSsnPScrb2JqW2tleV0rJyYnXG5cdH1cblx0cmV0dXJuIHN0ci5zbGljZSgwLCAtMSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmUoKXtcblx0bmFub2FqYXguYWpheCh7dXJsOmVuZHBvaW50cy5wcmVwYXJlLGJvZHk6dG9RdWVyeVN0cmluZyhkYXRhKSxtZXRob2Q6XCJwb3N0XCJ9LGdldClcbn1cblxuZnVuY3Rpb24gZ2V0KCl7XG5cdG5hbm9hamF4LmFqYXgoe3VybDplbmRwb2ludHMuZ2V0fSxlbmRDYilcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGlucHV0cywgY2IpID0+IHtcblx0ZGF0YSA9IGlucHV0c1xuXHRlbmRDYiA9IGNiXG5cdHByZXBhcmUoKVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuXG5cdHJldHVybiB7XG5cdFx0aXNMb2NrZWQ6ZmFsc2UsXG5cdFx0cmVnaXN0ZXI6ZnVuY3Rpb24oLi4uZWxzKXtcblx0XHRcdHRoaXMuZWxzID0gZWxzXG5cdFx0fSxcblx0XHRsb2NrOmZ1bmN0aW9uKCl7XG5cdFx0XHRmb3IgKGxldCBpPTA7IGkgPCB0aGlzLmVscy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHRoaXMuZWxzW2ldLmRpc2FibGVkID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5pc0xvY2tlZCA9IHRydWU7XG5cdFx0fSxcblx0XHR1bkxvY2s6ZnVuY3Rpb24oKXtcblx0XHRcdGZvciAobGV0IGk9MDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dGhpcy5lbHNbaV0uZGlzYWJsZWQgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG59XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIHByZXBhcmU6J2h0dHA6Ly9kZW1vNzA2MzYwMS5tb2NrYWJsZS5pby9wcmVwYXJlJyxcbiAgZ2V0OidodHRwOi8vZGVtbzcwNjM2MDEubW9ja2FibGUuaW8vZ2V0LXNoaXBwaW5nLXJhdGVzJ1xufVxuIiwiLyoqXG4gKiBPYmplY3QuYXNzaWduIGZhbGxiYWNrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAqL1xuaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIE9iamVjdC5hc3NpZ24pIHtcbiAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IE9iamVjdCh0YXJnZXQpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbn1cbiIsImltcG9ydCB7c2VsZWN0Tm9kZXN9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRhdGEsbW9kZWxEYXRhKSB7XG5cdGxldCBlbCA9IHNlbGVjdE5vZGVzKCdbZGF0YS10eXBlPVwicmVzdWx0XCJdJyx0aGlzKVxuXHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuXG5cdGlmICghZGF0YVsnc2hpcHBpbmdfcmF0ZXMnXSkgcmV0dXJuIFxuXHRsZXQgcmF0ZXMgPSBkYXRhWydzaGlwcGluZ19yYXRlcyddXG5cdGxldCBzdHJpbmcgPSAnJ1xuXG5cdGZvciAobGV0IGk9MDsgaSA8IHJhdGVzLmxlbmd0aDsgaSsrKXtcblx0XHRzdHJpbmcrPXJhdGVzW2ldLm5hbWUrXCI6IFwiK3JhdGVzW2ldLnByaWNlK1wiXFxyXFxuXCJcblx0fVxuXG5cdGVsLmlubmVySFRNTCA9IHN0cmluZ1xufVxuIiwiZnVuY3Rpb24gbm9kZUFycmF5KG5vZGVMaXN0KXtcblx0cmV0dXJuIFtdLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0Tm9kZXMoc3RyaW5nLGVsPWZhbHNlKXtcblx0bGV0IG5vZGVzID0gKGVsIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHN0cmluZylcblx0aWYgKCFub2Rlcy5sZW5ndGgpIHJldHVybiBmYWxzZVxuXHRsZXQgbm9kZXNBcnJheSA9IG5vZGVBcnJheShub2Rlcylcblx0aWYgKCBub2Rlc0FycmF5Lmxlbmd0aCA9PSAxICkgcmV0dXJuIG5vZGVzQXJyYXlbMF1cblx0cmV0dXJuIG5vZGVzQXJyYXlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGUobmFtZSwgYXR0cnMpIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLnRvU3RyaW5nKCkpO1xuXG5cdCEhYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xuXG5cdHJldHVybiBlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb3BzKCl7XG5cdGxldCBpc05vZGUgPSBwcm9wLm5vZGVUeXBlID8gdHJ1ZSA6IGZhbHNlXG5cdGxldCBpc051bWJlciA9ICdudW1iZXInID09PSB0eXBlb2YgcHJvcCA/IHRydWUgOiBmYWxzZVxuXG5cdGxldCBrZXkgPSBpc051bWJlciB8fCBpc05vZGUgPyAncmFuZ2UnIDogJ29wdGlvbnMnXG5cblx0aWYgKGlzTm9kZSB8fCBpc051bWJlcil7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG5cdFx0XHR2YWx1ZTogcHJvcCxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSlcblx0fSBlbHNlIGlmICghaXNOb2RlKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0YXJnZXQub3B0aW9ucywgcHJvcClcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnQoIG9iaiwgdHlwZSwgZm4gKSB7XG5cdGlmICggb2JqLmF0dGFjaEV2ZW50ICkge1xuXHRcdG9ialsnZScrdHlwZStmbl0gPSBmbjtcblx0XHRvYmpbdHlwZStmbl0gPSBmdW5jdGlvbigpe29ialsnZScrdHlwZStmbl0oIHdpbmRvdy5ldmVudCApO31cblx0XHRvYmouYXR0YWNoRXZlbnQoICdvbicrdHlwZSwgb2JqW3R5cGUrZm5dICk7XG5cdH0gZWxzZVxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG59XG4iLCJpbXBvcnQgJy4vbGliL3BvbHlmaWxscydcbmltcG9ydCB7c2VsZWN0Tm9kZXMsYWRkRXZlbnR9IGZyb20gJy4vbGliL3V0aWxzJ1xuaW1wb3J0IGFqYXggZnJvbSAnLi9saWIvYWpheCdcbmltcG9ydCByZXNwb25zZSBmcm9tICcuL2xpYi9yZXNwb25zZSdcbmltcG9ydCBMb2NrIGZyb20gJy4vbGliL2xvY2snXG5pbXBvcnQgU2VsZWN0IGZyb20gJy4vbGliL1NlbGVjdCdcblxuZXhwb3J0IGRlZmF1bHQgKGVsLGFyZ3M9e30pID0+IHtcblx0bGV0IGluc3RhbmNlXG5cblx0bGV0IHNldHRpbmdzID0ge1xuXHRcdGVuZHBvaW50czpbXG5cdFx0XHQnL2NhcnQvcHJlcGFyZV9zaGlwcGluZ19yYXRlcycsXG5cdFx0XHQnL2NhcnQvYXN5bmNfc2hpcHBpbmdfcmF0ZXMnXG5cdFx0XSxcblx0XHRzZWxlY3RDb250YWluZXI6J1tkYXRhLXR5cGU9XCJzZWxlY3QtY29udGFpbmVyXCJdJyxcblx0XHRyZXNwb25zZUNiOnJlc3BvbnNlLFxuXHRcdGRlZmF1bHRDb3VudHJ5OlwiVW5pdGVkIFN0YXRlc1wiXG5cdH1cblx0T2JqZWN0LmFzc2lnbihzZXR0aW5ncyxhcmdzKVxuXG5cdGxldCBzZWxlY3RXcmFwID0gc2VsZWN0Tm9kZXMoc2V0dGluZ3Muc2VsZWN0Q29udGFpbmVyLGVsKTtcblxuXHRsZXQgc2VsZWN0ID0gU2VsZWN0KCkuY29udGV4dChzZWxlY3RXcmFwKVxuXHRsZXQgY291bnRyeSAgPSBzZWxlY3QubWFrZSgnY291bnRyeScpXG5cdGxldCBwcm92aW5jZSA9IHNlbGVjdC5tYWtlKCdwcm92aW5jZScpXG5cdGxldCBtb2RlbCA9IHtcblx0XHRpc0xvY2tlZDogZmFsc2UsXG5cdFx0ZGF0YTp7fVxuXHR9O1xuXG5cdGFkZEV2ZW50KGNvdW50cnksICdjaGFuZ2UnLCAoZSkgPT4ge1xuXHRcdG1vZGVsLmNvdW50cnkgPSBlLnRhcmdldC52YWx1ZVxuXHR9KVxuXG5cdGFkZEV2ZW50KHByb3ZpbmNlLCAnY2hhbmdlJywgKGUpID0+IHtcblx0XHRtb2RlbC5wcm92aW5jZSA9IGUudGFyZ2V0LnZhbHVlXG5cdH0pXG5cblx0c2VsZWN0LnVwZGF0ZShjb3VudHJ5LCBDb3VudHJpZXMpXG5cblx0ZnVuY3Rpb24gbWFrZURlc2NyaXB0b3IocHJvcCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGF0YVtwcm9wXVxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsKXtcblx0XHRcdFx0dGhpcy5kYXRhW3Byb3BdPSB2YWxcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kZWwsJ2NvdW50cnknLHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50cnlcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24odmFsKXtcblx0XHRcdHRoaXMuZGF0YS5jb3VudHJ5ID0gdmFsXG5cdFx0XHRjb3VudHJ5LnZhbHVlID0gdmFsXG5cdFx0XHRzZWxlY3QudXBkYXRlKHByb3ZpbmNlLCB2YWwpXG5cdFx0XHR0aGlzLnByb3ZpbmNlID0gcHJvdmluY2UudmFsdWVcblx0XHR9XG5cdH0pXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVsLCdwcm92aW5jZScsIG1ha2VEZXNjcmlwdG9yKCdwcm92aW5jZScpIClcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVsLCd6aXAnLCBtYWtlRGVzY3JpcHRvcignemlwJykgKVxuXG5cdGxldCB6aXAgPSBzZWxlY3ROb2RlcygnW25hbWU9XCJ6aXBcIl0nLGVsKTtcblxuXHRhZGRFdmVudCh6aXAsICdibHVyJywgKGUpID0+IHtcblx0XHRtb2RlbC56aXAgPSB6aXAudmFsdWVcblx0fSlcblxuXHRsZXQgbG9jayA9IExvY2soKVxuXHRsb2NrLnJlZ2lzdGVyKGNvdW50cnkscHJvdmluY2UsemlwKVxuXHRcblx0Ly9IYW5kbGUgdGhlIHN1Ym1pc3Npb24gb2YgdGhlIGZvcm1cblx0YWRkRXZlbnQoZWwsICdzdWJtaXQnLCAoZSkgPT4ge1xuXHRcdGUucHJldmVudERlZmF1bHQoKVxuXG5cdFx0aWYgKCBsb2NrLmlzTG9ja2VkICkgcmV0dXJuIGZhbHNlXG5cdFx0bG9jay5sb2NrKClcblxuXHRcdGFqYXgoIG1vZGVsLmRhdGEsIChjb2RlLGRhdGEpID0+IHtcblx0XHRcdGxvY2sudW5Mb2NrKClcblx0XHRcdHNldHRpbmdzLnJlc3BvbnNlQ2IuY2FsbChlbCxkYXRhLG1vZGVsLmRhdGEpXG5cdFx0fSlcblx0fSlcblxuXHRtb2RlbC5jb3VudHJ5ID0gc2V0dGluZ3MuZGVmYXVsdENvdW50cnlcblxuXHRyZXR1cm4gaW5zdGFuY2Vcbn1cblxuIiwiaW1wb3J0IHtzZWxlY3ROb2Rlc30gZnJvbSBcIi4vLi4vc3JjL2xpYi91dGlsc1wiXG5pbXBvcnQgaW5zdGFuY2UgZnJvbSBcIi4vLi4vc3JjL21haW5cIlxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbigpe1xuXHRsZXQgZWxzID0gc2VsZWN0Tm9kZXMoJ1tkYXRhLWluaXQ9XCJzaGlwcGluZy1jYWxjdWxhdG9yXCJdJyk7XG5cdGZvciAobGV0IGk9MDtpPGVscy5sZW5ndGg7aSsrKXtcblx0XHRpbnN0YW5jZSggZWxzW2ldLCB7XG5cdFx0XHRlbmRwb2ludHM6W1xuXHRcdFx0XHQnaHR0cDovL2RlbW83MDYzNjAxLm1vY2thYmxlLmlvL3ByZXBhcmUnLFxuXHRcdFx0XHQnaHR0cDovL2RlbW83MDYzNjAxLm1vY2thYmxlLmlvL2dldC1zaGlwcGluZy1yYXRlcydcblx0XHRcdF0sXG5cdFx0XHRkZWZhdWx0Q291bnRyeTpcIkNhbmFkYVwiXG5cdFx0fSlcblx0fVxufSk7XG4iXX0=
